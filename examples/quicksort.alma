fn empty [ len | = 0 ]
fn small [ len | â‰¤ 1 ]
fn concat [ if* [= 0 len] [drop] [cons dip [concat] uncons] ]
fn 2dip f [ dip [dip f] ]
fn when* [ if* 2dip [ [] ] ]

# Given an element and two lists, cons the element onto the second one.
fn cons#2 [ swap | dip [cons] ]

# Given an element and three lists, cons the element onto the third one.
fn cons#3 [ swap | dip [cons#2] ]

# Sort one element into the partitioned lists.
fn sort-one-by comp [ if* [apply comp] [cons#2] [cons#3] uncons ]

# Partition the list by repeatedly calling sort-one-by starting with two empty result lists.
fn partition-by comp list [ while* [not empty] [sort-one-by comp] list {} {} | drop ]

# Quicksort: when list length > 1, partition, sort halves, and concatenate together.
fn quicksort [
    when* [not small] [             # only when list size > 1
        uncons -> pivot (
            partition-by [< pivot]  # Partition list
            quicksort               # Sort first half
            dip [quicksort]         # Sort second half
            cons#2 pivot            # Put pivot on front of second half
            concat                  # concatenate halves together
        )
    ]
]

fn main [
    # Sort random numbers from 1 to 10
    println quicksort { 3, 1, 6, 4, 10, 2, 5, 9, 8, 7 }

    # Sort random numbers from 1 to 100
    println quicksort { 64, 46, 26, 76, 94, 92, 57, 20, 81, 43,
                        58, 69, 33, 59, 32, 44, 90, 25, 28,  4,
                        24, 75, 34, 60, 49, 10, 98, 88, 48, 61,
                        41, 95, 74, 21,  5, 53, 86, 80, 66, 62,
                        96, 55,100, 84, 79,  6, 47, 17, 87, 15,
                        22, 19, 77, 23, 85, 18,  3, 63, 65, 70,
                        73, 56, 54, 45, 27, 72, 51, 31, 40, 29,
                         1,  7, 30, 71, 97, 38, 78, 11, 91, 50,
                        82, 93, 36, 68, 14,  8, 37, 42, 39,  9,
                        35, 12, 67, 13, 52, 89, 83,  2, 99, 16 }
]
